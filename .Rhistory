A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
library("mnormt")
algorithm <- function(b,A_pos,A_neg,maxiter=1e5,tol=1e-4,eps=1e-8){
beta_0 = rep(1,p)
beta_old = beta_0
for(iter in 1:maxiter){
a = A_pos %*% beta_old
c = A_neg %*% beta_old
beta_new = beta_old*(-b+sqrt((b^2+4*a*c)))/(2*a)
if(norm(beta_new-beta_old,"I")<tol){break}
beta_old = beta_new
# beta_old[which(beta_new<eps)]=0
}
# beta_new[which(beta_new<eps)]=0
return(beta_new)
}
# setting a
n = 100
p = 400
# set.seed(10000)
x_1 = rmnorm(n, mean = rep(0,p-1), varcov = diag(p-1))
e   = rnorm(n)
epsilon = rnorm(n)
x_p = apply(x_1[,1:6],1,sum)/8+x_1[,7]*3/8+e*7/8
x = cbind(x_1,x_p)
beta = c(2,3,4,1,rep(0,p-4))
y = x%*%beta + epsilon
xy = 2*t(x)%*%y
lambda_max = max(abs(xy))
lambda_min = lambda_max*1e-4
nlambda = 10
Lambda <- rev(seq(lambda_min, lambda_max, length.out = nlambda))
A = 2*t(x)%*%x
A_pos = pmax(A,0)
A_neg = pmax(-A,0)
betahat = matrix(NA, p, nlambda)
beta_0 = rep(1,p)
beta_old = beta_0
loss = rep(0, length(nlambda))
for(k in 1:nlambda){
print(k)
lambda = Lambda[k]
b = lambda - xy
beta_new = algorithm(b,A_pos,A_neg)
betahat[,k] = beta_new
beta_old = beta_new
loss[k] = sum(y - x%*%beta_new)^2
}
print(loss)
indx = which.min(loss)
coef = betahat[,indx]
print(indx)
print(which(coef>1e-6))
print(coef[coef>1e-6])
# print(betahat)
# betahat_sum = apply(betahat,2,sum)
# plot(betahat_sum, betahat[1,], type = "l", xlab = expression(paste("|"|"beta"*"|"[1])), ylab = "Coefficients")
log(49)//log(136)
log(49)/log(136)
136^{4/5}
136^{3/5}
log(49)/log(413)
413^{13/20}
413^{3/5}
413^{4/5}
136^{3/5}
136^{4/5}
413^{3/5}
413^{4/5}
setwd("D:/First/quantile/integrative analysis/qfabs_JAS/qfabs_JAS_revise/Code/qfabs")
library(devtools)
remove.packages(qfabs)
install_github("PanpanRen/qfabs")
library(qfabs)
library(qfabs)
library(mnormt)
M = 2
n1 = n2 = 20
n = c(n1, n2)
p = 50
beta = matrix(0, p, M)
index1 = 1:10
index2 = 2:11
beta[index1, 1] = runif(10, 0.2, 1.0)
beta[index2, 2] = runif(10, 0.4, 1.4)
distr = "gaussian"
rho = 0.5
dat = generator(n, p, beta, distr, rho)
x = dat$x
y = dat$y
tau = 0.2
Lambda2 = 0.001
fit <- mqfabs(y, x, n, tau, Lambda2)
fit$beta
fit1 <- mqfabs(y,x,n,tau,Lambda2, gamma = 0)
fit1$beta
