#' A minorization-maximization forward and backward stagewise algorithm for high-dimensional integrative quantile regression.
#'
#' @param y The response for \eqn{M} datasets, a numeric vector.
#' @param x The design matrix for \eqn{M} datasets.
#' @param n The sample sizes in multiple datasets. An integer vector in \eqn{R^{M}}, where \eqn{M} is the number of datasets.
#' @param tau The quantile to be estimated, this is a number strictly between 0 and 1. Default value is 0.5.
#' @param Lambda2 The value of the contrast penalty parameter(s) that determine how much shrinkage in different regression coefficients is done. This should be either a scalar, or a vector. If not specified then a sequence will be automatically generated based on the data.
#' @param nlambda2 The number of lambda2s generated. This is ignored if lambda is set manually. Default is 50.
#' @param Lambda2_thre Smallest value for lambda2, as a fraction of lambda2.max. Default is 1e-3.
#' @param epsilon The step size for updating coefficients. Default is 0.01.
#' @param delta A constant in pertubed loss function. Default is 1e-8.
#' @param xi The threshold for mqfabs. Default is 1e-10.
#' @param max.iter The maximum number of outer-loop iterations allowed. Default is 5000.
#' @param gamma A tuning parameter in EBIC. Default is 1.
#'
#' @return A list.
#' \itemize{
#'   \item beta - The optimal solution that minimizes EBIC.
#'   \item lambda1 - lambda1 sequence generated by mqfabs.
#'   \item Lambda2 - Lambda2 sequence.
#'   \item lambda2 - lambda2 returned that minimizes the EBIC across the lambda2 sequence.
#'   \item iter - Iterations.
#'   \item EBIC - The EBIC for each solution.
#'   \item opt - Position of the optimal lambda1 based on EBIC for lambda2.
#' }
#' @export
#'
#' @examples
#' data(simulatedData_gaussian)
#' y = dat$y
#' x = dat$x
#' n = dat$n
#' fit <- mqfabs(y, x, n)
#'
#' data(simulatedData_t3)
#' y = data_t3$y
#' x = data_t3$x
#' n = data_t3$n
#' fit <- mqfabs(y, x, n)
#'
#' data(simulatedData_cauchy)
#' y = data_cauchy$y
#' x = data_cauchy$x
#' n = data_cauchy$n
#' fit <- mqfabs(y, x, n)
#'
#' data(simulatedData_logistic)
#' y = data_logistic$y
#' x = data_logistic$x
#' n = data_logistic$n
#' fit <- mqfabs(y, x, n)
        
mqfabs = function(y, x, n, tau = 0.5, Lambda2 = NULL, nlambda2 = 50, Lambda2_thre = 1e-3, epsilon = 0.01, delta = 1e-8, xi = 1e-10, max.iter = 5000, gamma = 1){
    M = length(n)
    p = ncol(x)
    x = cbind(1, x)

    n_alter = rep(NA, M)
    n_alter[1] = n[1]
    for(m in 1:(M-1)){
        n_alter[m+1] = n_alter[m]+n[m+1]
    }

    if(is.null(Lambda2)){
        coer = rep(NA, M*p)
        index = 1:n[1]
        x1 = x[index,-1]
        y1 = y[index]
        coer[1:p] = abs(t(x1) %*% (y1 - quantile(y1, tau)))/n[1]
        for(m in 1:(M-1)){
            index = (n_alter[m]+1):(n_alter[m+1])
            x_1 = x[index,-1]
            y_1 = y[index]
            coer[(m*p+1):((m+1)*p)] = abs(t(x_1) %*% (y_1 - quantile(y_1, tau)))/n[m+1]
        }
        lambda2.max = max(coer)
        lambda2.min <- lambda2.max * Lambda2_thre 
        grid.n <- nlambda2
        lambda2.grid <- exp(seq(log(lambda2.min), log(lambda2.max), length.out=grid.n))
        Lambda2 = lambda2.grid
    }

    if(length(Lambda2) == 1){
        fit <- .Call("ESTIMATE_1", 
                as.numeric(y), 
                as.numeric(x), 
                as.integer(n_alter), 
                as.integer(M), 
                as.integer(p+1), 
                as.numeric(tau), 
                as.numeric(Lambda2), 
                as.numeric(epsilon), 
                as.numeric(delta), 
                as.numeric(xi), 
                as.integer(max.iter),
                as.numeric(gamma))
        iter = fit$iter
        fit$opt = which.min(fit$bic[1:(iter+1)])

        val = list(beta     = fit$betahat, 
                   iter     = iter, 
                   lambda1  = fit$lambda[1:(iter+1)], 
                   Lambda2  = Lambda2, 
                   lambda2  = Lambda2, 
                   bic      = fit$bic[1:(iter+1)], 
                   opt      = fit$opt)
    }else{
        L = length(Lambda2)
        bics = rep(NA, L)
        for(l in 1:L){
            fit <- .Call("_ESTIMATE", 
                    as.numeric(y), 
                    as.numeric(x), 
                    as.integer(n_alter), 
                    as.integer(M), 
                    as.integer(p+1), 
                    as.numeric(tau), 
                    as.numeric(Lambda2[l]), 
                    as.numeric(epsilon), 
                    as.numeric(delta), 
                    as.numeric(xi), 
                    as.integer(max.iter),
                    as.numeric(gamma))
            Bic = fit$bic
            iter = fit$iter
            bic = min(Bic[1:(iter+1)])
            bics[l] = bic
        }
        indice = which.min(bics)
        lambda2 = Lambda2[indice]
        result1 = .Call("ESTIMATE_1", 
                    as.numeric(y), 
                    as.numeric(x), 
                    as.integer(n_alter), 
                    as.integer(M), 
                    as.integer(p+1), 
                    as.numeric(tau), 
                    as.numeric(lambda2), 
                    as.numeric(epsilon), 
                    as.numeric(delta), 
                    as.numeric(xi), 
                    as.integer(max.iter),
                    as.numeric(gamma))
        iter = result1$iter
        result1$opt = which.min(result1$bic[1:(iter+1)])

        val = list(beta     = result1$betahat, 
                   iter     = iter, 
                   lambda1  = result1$lambda[1:(iter+1)], 
                   Lambda2  = Lambda2, 
                   lambda2  = lambda2, 
                   EBIC     = result1$bic[1:(iter+1)], 
                   opt      = result1$opt)
    }

    return(val)
}




